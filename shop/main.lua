---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Kevin.
--- DateTime: 06.12.2019 21:45
---

local config    = require("shop.config")
local component = require("component")
if config.address_redstone_autostart then
    component.proxy(config.address_redstone_autostart).setWakeThreshold(10)
end
local filesystem       = require("filesystem")
local should_terminate = false
local function main_loop()
    while should_terminate == false do
        pcall(os.sleep, 5)
        -- do nothing but prevent hard interrupt CTRL+ALT+C from terminating program
        -- too many interrupts can however make the PC freeze.. would need an external WDT?
    end
    print("main exited")
end

if type(config.path_mounts) ~= "table" then
    config.path_mounts = { config.path_mounts }
end
for i, path in pairs(config.path_mounts) do
    if not filesystem.exists(path) then
        print("Sorry, the mountpoint " .. path .. " could not be found. Can't start")
        main_loop()
    end
end

local log = require("shop.logging")
if not log.init(config.path_logfile, config.path_logfile_transactions, config.log_lines_textbox, config.max_filesize_log) then
    print("Initializing logs failed")
    main_loop()
end
local thread = require("thread")
component.gpu.setResolution(160, 50)
local gui      = require("shop.shopGUI")
local GUI      = require("GUI")
local computer = require("computer")
local json     = require("json")
local accounts = require("shop.accounts")
local event    = require("event")
local backend  = require("shop.backend")
local math     = require("math")

log.setTextBox(gui.textBox_logs)
log.setTextBoxTransactions(gui.textBox_transactions)

----
local items           = {}
local items_tree      = {}
local payer           = { ["name"] = nil, ["time"] = 0 }

-------------------------------
-- GUI

gui.menu_exit.onTouch = function(workspace, object, e2, e3, e4, e5, e6, user)
    if user == config.owner then
        should_terminate = true
        gui.workspace:stop()
        return
    end
    --gui.on_alert = true
    GUI.notice(workspace, 5, "You are not authorized to terminate this program!")
    --gui.on_alert = false
end

-------------------------------
-- Items

local function loadItems()
    local f = io.open(config.path_file_items, "r")
    if f == nil then
        log.error("Error loading items file from " .. config.path_file_items)
        return false
    end
    local it = f:read("*a")
    f:close()
    it = json.decode(it)
    return it
end

local function loadItemsForTree()
    local it = {}
    local item_cat
    for item_ident, item in pairs(items) do
        item_cat = item.name:sub(1, item.name:find(":") - 1)
        if not it[item_cat] then
            it[item_cat] = {}
        end
        it[item_cat][item_ident] = true
        if item.categories then
            for _, cat in pairs(item.categories) do
                if not it[cat] then
                    it[cat] = {}
                end
                it[cat][item_ident] = true
            end
        end
    end
    items_tree = it
    gui.updateTree(gui.tree_items, items_tree, items)
end

gui.tree_items.onItemExpanded = function()
    gui.updateTree(gui.tree_items, items_tree, items)
end

local function getNBT(item)
    local nbt = {}
    for key, val in pairs(item) do
        if not config.identity_blacklist[key] then
            nbt[key] = val
        end
    end
    return nbt
end

local function requestItemToStock(ident, nbt, amount, is_craftable)
    if is_craftable ~= false then
        is_craftable = true
    end
    local item     = {}
    item.ident     = ident
    item.nbt       = nbt
    item.amount    = amount
    item.craftable = is_craftable
    item.time      = os.time()
    component.tunnel.send(json.encode(item))
end

local function organizeItems(it)
    items = {}
    local tunnel
    if component.isAvailable("tunnel") then
        tunnel = component.tunnel
    end
    local cells        = backend.getAmountAvailable(config.nbt_portable_cell)
    local its          = backend.getAmountItemsInNetwork()
    local me_available = true
    if its == 0 or its == 1 and cells > 0 then
        log.debug("No items in network on startup, assuming network currently offline")
        me_available = false
    end
    for i, item in pairs(it) do
        local ident  = config.getItemIdentityName(item)
        items[ident] = item
        if tunnel and item.stock and me_available then
            local nbt       = getNBT(item)
            local available = backend.getAmountAvailable(nbt)
            if available < item.stock then
                requestItemToStock(ident, nbt, item.stock - available)
                os.sleep(0.1)
            end
        end
    end
end

gui.tree_items.onItemSelected   = function(selected, e1, e2, e3, e4, e5, user)
    accounts.displayBuyerInformation(user, gui.textBox_buyerInfo, gui.workspace)
    local nbt                     = {}
    gui.tree_amounts.items        = {}
    gui.tree_amounts.selectedItem = nil
    gui.button_addToCart.disabled = true
    if items[selected] then
        local nbt_t = getNBT(items[selected])
        for key, val in pairs(nbt_t) do
            if type(val) ~= "table" then
                nbt[#nbt + 1] = key .. ": " .. tostring(val)
            end
        end
        local amounts = {}
        for size, price in pairs(items[selected].amounts) do
            amounts[#amounts + 1] = tonumber(size)
        end
        table.sort(amounts)
        for _, size in pairs(amounts) do
            gui.tree_amounts:addItem(
                    size .. " -> " .. tostring(items[selected].amounts[tostring(size)]) .. "$",
                    size,
                    1,
                    false,
                    false
            )
        end
        local available = backend.getAmountAvailable(nbt_t)
        if not available then
            available = 0
        end
        gui.label_available_items.text = "Amount available: " .. tostring(available)
    else
        gui.label_available_items.text = ""
    end
    gui.textBox_itemInfo.lines = nbt
    while gui.on_alert do
        os.sleep(0.1)
    end
    gui.workspace:draw()
end

gui.tree_amounts.onItemSelected = function(selected, e1, e2, e3, e4, e5, user)
    accounts.displayBuyerInformation(user, gui.textBox_buyerInfo, gui.workspace)
    gui.button_addToCart.disabled = false
    while gui.on_alert do
        os.sleep(0.1)
    end
    gui.workspace:draw()
end

local function rebuildShoppingCart()
    gui.tree_shoppingCart.items = {}
    for i, item in pairs(gui.tree_shoppingCart.transaction.item_pairs) do
        local label = item.item.label
        if item.item.label_friendly then
            label = item.item.label_friendly
        end
        gui.tree_shoppingCart:addItem(
                item.size .. "x " .. label .. " = " .. tostring(item.price) .. "$",
                json.encode({ label, item.size }),
                1,
                false,
                false
        )
    end
end

local function updateTransactionLabels()
    gui.label_transaction_value.setValue(gui.tree_shoppingCart.transaction.transaction_value, false)
    gui.label_item_value.setValue(gui.tree_shoppingCart.transaction.item_value, false)
    gui.label_cell_lease_value.setValue(gui.tree_shoppingCart.transaction.lease_value, false)
end

gui.button_addToCart.onTouch = function(workspace, button, e1, e2, e3, e4, e5, user)
    accounts.displayBuyerInformation(user, gui.textBox_buyerInfo, gui.workspace)
    local item  = items[gui.tree_items.selectedItem]
    local label = item.label
    if item.label_friendly then
        label = item.label_friendly
    end
    local nbt       = getNBT(item)
    local requested = gui.tree_amounts.selectedItem
    if not requested then
        return -- probably due to race condition between disabling button and click?
    end
    requested       = requested + gui.tree_shoppingCart.transaction.getAmountOfItem(config.getItemIdentityName(nbt))
    local available = backend.getAmountAvailable(nbt)
    if available < requested then
        --gui.on_alert = true
        GUI.notice(workspace, 8, "Can't add this amount because not enough items available in the shop. Sorry")
        --gui.on_alert = false
        return
    end
    gui.tree_shoppingCart.transaction.addItem(config.getItemIdentityName(item), item, gui.tree_amounts.selectedItem, item.amounts[tostring(gui.tree_amounts.selectedItem)])
    gui.button_confirm.disabled = false
    rebuildShoppingCart()
    updateTransactionLabels()
    gui.workspace:draw()
end

local function resetTransaction()
    gui.tree_shoppingCart.items       = {}
    gui.tree_shoppingCart.transaction = config.newTransaction()
    gui.button_addToCart.disabled     = true
    gui.tree_amounts.selectedItem     = nil
    gui.tree_items.selectedItem       = nil
    gui.tree_amounts.items            = {}
    gui.textBox_itemInfo.lines        = {}
    gui.button_confirm.disabled       = true
    updateTransactionLabels()
    gui.workspace:draw()
end

gui.button_abort.onTouch = function(workspace, button, e1, e2, e3, e4, e5, user)
    resetTransaction()
    --gui.on_alert = true
    GUI.notice(workspace, 5, "Transaction aborted")
    --gui.on_alert = false
end

local function rollbackTransaction(trans)
    local value = 0
    for i, item in pairs(trans.item_pairs) do
        value = value + item.price
    end
    value       = value + trans.lease_value
    local buyer = accounts.getBuyer(trans.buyer)
    accounts.refundedLeasedCells(buyer, trans.leased_cells)
    accounts.addMoneyToBuyer(buyer, value)
    log.transaction(buyer.name .. " refunded " .. tostring(value) .. "$: " .. trans.toJson())
    --gui.on_alert = true
    GUI.notice(gui.workspace, 15, "Sorry, exporting didn't work. We refunded you " .. value .. "$ for the missing items. Please contact the owner " .. config.owner)
    --gui.on_alert = false
    backend.ejectPortableCell() -- just trying
end

local function showExportProgress(done, requested)
    if done > 0 and requested > 0 then
        gui.progressBarItem.value        = math.floor(done / requested * 100)
        gui.progressBarItem.valuePostfix = "%, " .. tostring(done) .. "/" .. tostring(requested) .. " items"
        gui.workspace:draw()
    end
end

local function exportItems(trans)
    local cell_slots_used            = 0
    local cell_items_stored          = 0
    gui.progressBar.hidden           = false
    gui.progressBar.valuePostfix     = "%, " .. tostring(0) .. "/" .. tostring(#trans.item_pairs) .. " items"
    gui.progressBar.value            = 0
    gui.progressBarItem.hidden       = false
    gui.progressBarItem.valuePostfix = "%, " .. tostring(0) .. "/" .. tostring(0) .. " items"
    gui.progressBarItem.value        = 0
    gui.workspace:draw()
    local temp_until_ejected = {}
    local to_dropper         = true
    local redstone           = component.proxy(config.address_redstone_dropper)
    if trans.leased_cells > 0 then
        to_dropper = false
        if not backend.exportPortableCell() then
            rollbackTransaction(trans)
            redstone.setOutput(config.side_redstone_dropper, 0)
            return false
        end
    end
    redstone.setOutput(config.side_redstone_dropper, 255)
    --if to_dropper then
    --    redstone.setOutput(config.side_redstone_dropper, 255)
    --end
    for i, item in pairs(trans.item_pairs) do
        if not to_dropper then
            if cell_items_stored + item.size > config.maxSize_portableCell or cell_slots_used >= config.maxSlots_portableCell then
                if not backend.ejectPortableCell() then
                    rollbackTransaction(trans)
                    redstone.setOutput(config.side_redstone_dropper, 0)
                    return false
                end
                -- successfully exported and ejected
                for _, j in pairs(temp_until_ejected) do
                    trans.item_pairs[j].size  = 0
                    trans.item_pairs[j].price = 0
                end
                temp_until_ejected = {}
                trans.leased_cells = trans.leased_cells - 1
                trans.lease_value  = trans.leased_cells * config.price_lease_storage_cell
                cell_slots_used    = 0
                cell_items_stored  = 0
                if not backend.exportPortableCell() then
                    rollbackTransaction(trans)
                    redstone.setOutput(config.side_redstone_dropper, 0)
                    return false
                end
            end
            local success, amount = backend.exportIntoChest(item.item, item.size, showExportProgress)
            if component.isAvailable("tunnel") and items[item.ident].stock then
                local nbt       = getNBT(item.item)
                local available = backend.getAmountAvailable(nbt)
                if available < items[item.ident].stock then
                    requestItemToStock(config.getItemIdentityName(item.item), nbt, items[item.ident].stock - available)
                end
            end
            if not success then
                -- calculate percentage that has to be refunded
                item.price = item.price * (item.size - amount) / item.size
                item.size  = item.size - amount
                rollbackTransaction(trans)
                redstone.setOutput(config.side_redstone_dropper, 0)
                return false
            else
                cell_slots_used                             = cell_slots_used + 1
                cell_items_stored                           = cell_items_stored + item.size
                temp_until_ejected[#temp_until_ejected + 1] = i
            end
        else
            local success, amount = backend.exportToDropper(item.item, item.size, showExportProgress)
            if component.isAvailable("tunnel") and items[item.ident].stock then
                local nbt       = getNBT(item.item)
                local available = backend.getAmountAvailable(nbt)
                if available < items[item.ident].stock then
                    requestItemToStock(config.getItemIdentityName(item.item), nbt, items[item.ident].stock - available)
                end
            end
            if not success then
                -- calculate percentage that has to be refunded
                item.price = item.price * (item.size - amount) / item.size
                item.size  = item.size - amount
                rollbackTransaction(trans)
                redstone.setOutput(config.side_redstone_dropper, 0)
                return false
            else
                item.size  = 0
                item.price = 0
            end
        end
        gui.progressBar.value        = math.floor(i / #trans.item_pairs * 100)
        gui.progressBar.valuePostfix = "%, " .. tostring(i) .. "/" .. tostring(#trans.item_pairs) .. " items"
        gui.workspace:draw()
    end
    if to_dropper then
        redstone.setOutput(config.side_redstone_dropper, 0)
        return true
    else
        if not backend.ejectPortableCell() then
            rollbackTransaction(trans)
            redstone.setOutput(config.side_redstone_dropper, 0)
            return false
        end
        redstone.setOutput(config.side_redstone_dropper, 0)
        return true
    end
end

local function freezeGUI()
    gui.tree_items.disabled   = true
    gui.tree_amounts.disabled = true
    gui.button_abort.disabled = true
    gui.workspace:draw()
end

local function unfreezeGUI()
    gui.tree_items.disabled   = false
    gui.tree_amounts.disabled = false
    gui.button_abort.disabled = false
    gui.workspace:draw()
end

gui.button_confirm.onTouch = function(workspace, button, e1, e2, e3, e4, e5, user)
    local buyer = accounts.getBuyer(user)
    accounts.displayBuyerInformation(buyer.name, gui.textBox_buyerInfo, gui.workspace)
    local transaction = gui.tree_shoppingCart.transaction
    transaction.buyer = buyer.name
    if buyer.money < transaction.transaction_value then
        --gui.on_alert = true
        GUI.notice(workspace, 7, "Transaction not possible because of insufficient funds")
        --gui.on_alert = false
        return
    end
    gui.button_confirm.disabled = true
    freezeGUI()
    accounts.leaseCells(buyer, transaction.leased_cells)
    accounts.removeMoneyFromBuyer(buyer, transaction.transaction_value)
    accounts.displayBuyerInformation(buyer.name, gui.textBox_buyerInfo, gui.workspace)
    -- export now so transaction can not be manipulated after confirmation
    log.transaction(user .. " bought " .. transaction.toJson())
    local success = exportItems(transaction)
    backend.emptyRemainingInput()
    gui.progressBar.hidden     = true
    gui.progressBarItem.hidden = true
    if success then
        resetTransaction()
        --gui.on_alert = true
        GUI.notice(workspace, 10, "Transaction complete! Thanks for buying! \n\nYou will find your purchases to the right, in front of the dropper.")
        --gui.on_alert = false
    end
    unfreezeGUI()
end


-------------------------------
--
local function listenMotion(name, id, x, y, z, player)
    if payer.name == player then
        payer.time = computer.uptime()
    else
        payer = { ["name"] = player, ["time"] = computer.uptime() }
        if gui.on_alert then
            return
        end
        accounts.displayBuyerInformation(payer.name, gui.textBox_buyerInfo, gui.workspace)
    end
end

local function createMoneyDisks(amount, value)
    local transposer = component.proxy(config.address_transposer_money_drive)
    local items      = transposer.getAllStacks(config.side_money_disk_input).getAll()
    local drive      = component.proxy(config.address_disk_drive_money)
    local me_money   = component.proxy(config.address_me_money)
    local output     = me_money.getItemsInNetwork()
    if output.n >= config.maxSlots_money_storage then
        log.error("Money output me is full, can't create new ones")
        return false
    end
    local created = 0
    for i = 1, amount do
        for slot = 1, transposer.getAllStacks(config.side_money_disk_input).count() do
            if config.getItemIdentityName(items[slot], { "label" }) == config.identity_floppy_disk then
                if transposer.transferItem(config.side_money_disk_input, config.side_money_drive, slot, 1) ~= 1.0 then
                    log.error("Error moving floppy disk into money drive")
                    return false
                end
                accounts.createMoneyDisk(value)
                drive.eject()
                if not drive.isEmpty() then
                    log.error("Error ejecting floppy disk from money drive")
                    return false
                end
                created = created + 1
                break
            end
        end
    end
    if created < amount then
        log.error("Only created " .. tostring(created) .. " money disks, requested " .. tostring(amount))
        return false
    end
    return true
end

gui.button_createMoneyDisks.onTouch = function(workspace, button, e1, e2, e3, e4, e5, user)
    local res = createMoneyDisks(tonumber(gui.input_amount_money_disks.text), tonumber(gui.input_value_money_disks.text))
    --gui.on_alert = true
    if res then
        GUI.notice(workspace, 10, "Finished creating money")
    else
        GUI.notice(workspace, 10, "Failed creating money")
    end
    --gui.on_alert = false
end

gui.menu_money_disks.onTouch        = function(workspace, object, e2, e3, e4, e5, e6, user)
    gui.textBox_money_disks.hidden = not gui.textBox_money_disks.hidden
    local money                    = accounts.getMoneyDisksDict()
    local lines                    = {}
    for addr, value in pairs(money) do
        lines[#lines + 1] = addr .. "    " .. tostring(value) .. "$"
    end
    gui.textBox_money_disks.lines = lines
    workspace:draw()
end

-------------------------------
-- Start everything

local function info()
    while not should_terminate do
        gui.label_uptime.text = "Uptime: " .. tostring(computer.uptime())
        gui.label_ram.text    = "RAM free: " .. string.format("%02.2f", tostring(computer.freeMemory() / 1024)) .. "kB"
        if not gui.on_alert then
            gui.workspace:draw()
        end
        os.sleep(2)
    end
    print("info exited")
end

local function gui_func()
    resetTransaction()
    event.listen("motion", listenMotion)
    gui.workspace:start()
    event.ignore("motion", listenMotion)
    print("GUI exited")
end

local vacuum_should_terminate = false
local vacuum_running          = false

local function watch_vacuum(buyer)
    local redstone = component.proxy(config.address_redstone_vacuum_chest)
    redstone.setOutput(config.side_redstone_vacuum_chest, 255) -- pull items in
    while not vacuum_should_terminate do
        os.sleep(1)
    end
    local success, actions = backend.sortInputChest(buyer)
    if success then
        while gui.on_alert do
            os.sleep(0.5)
        end
        accounts.displayBuyerInformation(buyer.name, gui.textBox_buyerInfo, gui.workspace)
        --gui.on_alert = true
        GUI.notice(gui.workspace, 20, actions)
        --gui.on_alert = false
    end
    redstone.setOutput(config.side_redstone_vacuum_chest, 0)
    backend.emptyRemainingInput()
    vacuum_running = false
end

local function kill_vacuum()
    vacuum_should_terminate = true
end

gui.button_start_vacuum.onTouch = function(workspace, object, e2, e3, e4, e5, e6, user)
    if vacuum_running then
        return
    end
    local buyer             = accounts.getBuyer(user)
    vacuum_should_terminate = false
    vacuum_running          = true
    GUI.notice(workspace, 30, "Drop your empty Portable Storage Cells or Money Floppy Disks in front of the vacuum chest.\n\nPress ok once done or wait 30 seconds.", kill_vacuum, false, 5)
    local th = thread.create(watch_vacuum, buyer)
end

local function wrap(name, func, ...)
    local no_interrupt = false
    if name == "info" or name == "stock" then
        no_interrupt = true
    end
    while true and not should_terminate do
        local res, ret = pcall(func, ...)
        if not res and not no_interrupt then
            print(name, ret)
            log.critical(name .. ": " .. tostring(ret))
        end
        if not no_interrupt then
            return
        end
    end
end

local function stock()
    local tunnel
    if component.isAvailable("tunnel") then
        tunnel = component.tunnel
    else
        log.warn("No tunnel available, can't watch stock")
        return false
    end
    while not should_terminate do
        local st = computer.uptime()
        while computer.uptime() - st < config.stock_scanning_interval do
            os.sleep(5)
            if should_terminate then
                print("Stock exited")
                log.info("Stock exited e1")
                return
            end
        end
        os.sleep(5)
        local me, err = component.proxy(config.address_me_storage)
        if me == nil and err then
            log.warn("ME system not available")
        else
            local its = me.getItemsInNetwork()
            if its.n == 0 or (its.n == 1 and config.getItemIdentityName(its[1]) == config.identity_portable_cell) then
                log.warn("ME system empty, n " .. tostring(its.n))
                -- n=1 are portable cells in normal chest
            else
                local stored = {}
                for i, item in pairs(its) do
                    if i ~= "n" then
                        stored[config.getItemIdentityName(item)] = item
                    end
                end
                local reqc = 0
                for ident, item in pairs(items) do
                    if item.stock and stored[ident] == nil then
                        -- item not available in ME system yet
                    elseif item.stock and item.stock > stored[ident].size then
                        --log.debug("Requesting item " .. ident .. " " .. tostring(item.stock - stored[ident].size))
                        reqc = reqc + 1
                        requestItemToStock(ident, getNBT(item), item.stock - stored[ident].size, item.craftable)
                        os.sleep(0.25)
                    end
                end
                log.debug("Found " .. tostring(its.n) .. " items in ME, requested " .. tostring(reqc) .. " items")
            end
        end
    end
    log.info("Stock exited e2")
    print("Stock exited")
end

local function init()
    local notice = GUI.notice(gui.workspace, nil, "Starting, please wait...", nil, false)
    backend.ejectPortableCell() -- just in case of error
    local it = loadItems()
    if it then
        organizeItems(it)
        loadItemsForTree()
    end
    --gui.workspace:draw(true)
    notice()
end

local function start()
    local thread_gui   = thread.create(wrap, "gui_func", gui_func)
    local thread_init  = thread.create(wrap, "init", init)
    local thread_info  = thread.create(wrap, "info", info)
    local thread_stock = thread.create(wrap, "stock", stock)
    --local thread_loop   = thread.create(wrap, "main_loop", main_loop)
    -- component.proxy(config.address_redstone_export).setOutput(config.side_export_redstone, 0) -- in case of error
    log.info("Started")
end

start()
main_loop()
--gui_func()

-- TODO: test error retrieval in thread and lock GUI in case of error? --> works so far
-- TODO: create how-to
-- TODO: show loading progress on startup
-- TODO: add category for all items
-- TODO: add search
-- TODO: use flushing only on startup and after mass export -> not using mass export anymore
-- TODO: use ntptime module

-- TODO: check if enough storage cells are available for a transaction
-- TODO: add confirmation/abort dialog GUI component
-- TODO: use confirmation dialog before dropping items to ensure only the user gets the items/clearlagg confirmation
-- TODO: show error message if unrecoverable error happens (e.g. mountpoints unavailable, loop exited...)
-- TODO: add button to collapse/reset all categories
-- TODO: add proper message when disk with no value got returned (either error or more likely forgery)
-- TODO: implement logrotate for 2 logs to fit into a HDD